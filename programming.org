#+title: Programming

Configuration for programming and languages support.

#+begin_src emacs-lisp
  ;;; -*- lexical-binding: t -*-
#+end_src

* Eldoc
#+begin_src emacs-lisp
  (straight-use-package 'eldoc-box)
#+end_src

** Replace the default C-h .

#+begin_src emacs-lisp
  (keymap-set global-map "C-h ."  'eldoc-box-help-at-point)
#+end_src

* Custom format buffer function
#+begin_src emacs-lisp
  (defun meomacs-default-format-buffer ()
    (interactive)
    (save-mark-and-excursion
      (indent-region-line-by-line (point-min) (point-max))))

  (defun meomacs-format-buffer ()
    "Format whole buffer with LSP and fallback behavior."
    (interactive)
    (if (and
         (bound-and-true-p lsp-mode)
         lsp-enable-indentation)
        (call-interactively #'lsp-format-buffer)
      (call-interactively 'meomacs-default-format-buffer)))

  (global-set-key (kbd "C-c C-f") 'meomacs-format-buffer)
#+end_src

* Topsy

Show current function signature in header line.

#+begin_src emacs-lisp
  (straight-use-package
   '(topsy :host github :repo "alphapapa/topsy.el"))

  (keymap-set prog-mode-map "C-c t s" 'topsy-mode)
#+end_src

* Force save file
#+begin_src emacs-lisp
  (defun save-buffer-always ()
    "Save the buffer even if it is not modified."
    (interactive)
    (set-buffer-modified-p t)
    (save-buffer))

  (global-set-key (kbd "C-c w") 'save-buffer-always)
#+end_src

* Flycheck

#+begin_src emacs-lisp
  (straight-use-package 'flycheck)

  (setq flycheck-check-syntax-automatically '(save idle-buffer-switch mode-enabled))
#+end_src

* Lisp Parenthese
#+begin_src emacs-lisp
  (straight-use-package 'paredit)

  (require 'paredit)

  (define-key emacs-lisp-mode-map (kbd "C-c )") 'paredit-forward-slurp-sexp)
  (define-key emacs-lisp-mode-map (kbd "C-c (") 'paredit-forward-barf-sexp)
#+end_src

* LSP

** COMMENT lspce

Use lspce as LSP client.

#+begin_src emacs-lisp
  (straight-use-package '(lspce :host github
                                :repo "zbelial/lspce"
                                :files (:defaults "lspce-module.so")
                                :pre-build (("cargo" "build" "--release")
                                            ("cp" "./target/release/liblspce_module.so" "./lspce-module.so"))))

  (autoload 'lspce-mode "lspce" nil t)

  (with-eval-after-load "lspce"
    (define-key lspce-mode-map (kbd "C-c l r") 'lspce-rename)
    (define-key lspce-mode-map (kbd "C-c l a") 'lspce-code-actions)
    (define-key lspce-mode-map (kbd "C-c l h") 'lspce-help-at-point))
#+end_src

*** Key binding

#+begin_src emacs-lisp
  (keymap-set prog-mode-map "C-c L" 'lspce-mode)
#+end_src

** COMMENT Lsp-mode

Use lsp-mode as LSP client.

#+begin_src emacs-lisp
  (setenv "LSP_USE_PLISTS" "true")

  (straight-use-package 'lsp-mode)

  (setq lsp-keymap-prefix "C-c l"
        lsp-enable-symbol-highlighting nil
        lsp-enable-dap-auto-configure nil
        lsp-lens-enable nil
        lsp-headerline-breadcrumb-enable nil
        lsp-signature-doc-lines 3
        lsp-auto-execute-action nil
        lsp-enable-on-type-formatting nil)

  (setq lsp-disabled-clients '(tfls clangd rls rnix-lsp semgrep-ls deno-ls))

  (setq-default lsp-rust-analyzer-cargo-watch-command "check"
                lsp-eldoc-render-all t)

  (autoload 'lsp "lsp-mode" nil t)

  (with-eval-after-load "lsp-mode"
    (keymap-set lsp-mode-map "M-RET" 'lsp-execute-code-action))
#+end_src

*** Key binding

#+begin_src emacs-lisp
  (keymap-set prog-mode-map "C-c L" 'lsp)
#+end_src

*** Lsp Booster
#+begin_src emacs-lisp
  (defun lsp-booster--advice-json-parse (old-fn &rest args)
    "Try to parse bytecode instead of json."
    (or
     (when (equal (following-char) ?#)
       (let ((bytecode (read (current-buffer))))
         (when (byte-code-function-p bytecode)
           (funcall bytecode))))
     (apply old-fn args)))
  (advice-add (if (progn (require 'json)
                         (fboundp 'json-parse-buffer))
                  'json-parse-buffer
                'json-read)
              :around
              #'lsp-booster--advice-json-parse)

  (defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
    "Prepend emacs-lsp-booster command to lsp CMD."
    (let ((orig-result (funcall old-fn cmd test?)))
      (if (and (not test?)                             ;; for check lsp-server-present?
               (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
               lsp-use-plists
               (not (functionp 'json-rpc-connection))  ;; native json-rpc
               (executable-find "emacs-lsp-booster"))
          (progn
            (message "Using emacs-lsp-booster for %s!" orig-result)
            (cons "emacs-lsp-booster" orig-result))
        orig-result)))

  (advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command)
#+end_src

*** COMMENT Lsp-ui

#+begin_src emacs-lisp
  (straight-use-package 'lsp-ui)

  (add-hook 'lsp-mode-hook 'lsp-ui-mode)
#+end_src

** Eglot

Use eglot as LSP client.

#+begin_src emacs-lisp
  (autoload 'eglot "eglot" nil t)

  (setq eglot-ignored-server-capabilities
        '(:documentHighlightProvider
          :inlayHintProvider
          :workspaceSymbolProvider))

  (setq eglot-stay-out-of '(yasnippet))

  (with-eval-after-load "eglot"
    (define-key eglot-mode-map (kbd "<C-return>") 'eglot-code-actions))
#+end_src

*** Use lsp-booster

#+begin_src emacs-lisp
  (straight-use-package
   '(eglot-booster :host github
                   :repo "jdtsmith/eglot-booster"))

  (add-hook 'eglot-mode-hook 'eglot-booster-mode)
#+end_src

*** Key Binding

#+begin_src emacs-lisp
  (keymap-set prog-mode-map "C-c L" 'eglot)
#+end_src

* Clojure

** COMMENT Clojure-mode

Use clojure-ts-mode instead of clojure-mode.

#+begin_src emacs-lisp
  (straight-use-package 'clojure-ts-mode)

  (setq clojure-ts-toplevel-inside-comment-form t)

  (with-eval-after-load "clojure-ts-mode"
    (define-key clojure-mode-map (kbd "C-c M-j") 'cider-jack-in)
    (define-key clojure-mode-map (kbd "C-c M-J") 'cider-jack-in-cljs))
#+end_src

** Clojure-ts-mode

Use clojure-mode for basic syntax support.

#+begin_src emacs-lisp
  (straight-use-package 'clojure-ts-mode)

  (with-eval-after-load "clojure-ts-mode"
    (setq clojure-ts-toplevel-inside-comment-form t)
    (keymap-set clojure-ts-mode-map "C-c )" 'paredit-forward-slurp-sexp)
    (keymap-set clojure-ts-mode-map "C-c (" 'paredit-forward-barf-sexp))
#+end_src

** Inf-Clojure

A lightweight integration to socket repl.

#+begin_src emacs-lisp
  (straight-use-package 'inf-clojure)

  (autoload 'inf-clojure "inf-clojure" t t)
  (autoload 'inf-clojure-connect "inf-clojure" t t)

  (with-eval-after-load "clojure-ts-mode"
    (keymap-set clojure-ts-mode-map "C-c M-c" 'inf-clojure-connect))
#+end_src

** Jarchive
For opening .jar files. This is required for Eglot.

#+begin_src emacs-lisp
  (straight-use-package 'jarchive)

  (with-eval-after-load "clojure-ts-mode"
    (jarchive-mode))
#+end_src

** COMMENT Cider for REPL connection

#+begin_src emacs-lisp
  (straight-use-package 'cider)

  (autoload 'cider-jack-in "cider" nil t)

  (setq cider-offer-to-open-cljs-app-in-browser nil
        cider-preferred-build-tool 'shadow-cljs
        cider-repl-type 'shadow)
#+end_src

** COMMENT Linting with flycheck-clj-kondo

#+begin_src emacs-lisp
  (straight-use-package 'flycheck-clj-kondo)

  (with-eval-after-load "clojure-ts-mode"
    (require 'flycheck-clj-kondo))

  (add-hook 'clojure-mode-hook 'flycheck-mode)
#+end_src

** COMMENT Format code with zprint

#+begin_src emacs-lisp
  (straight-use-package '(zprint :type git
                                 :host github
                                 :repo "DogLooksGood/zprint.el"))

  (autoload 'zprint "zprint" nil t)

  (with-eval-after-load "clojure-ts-mode"
    (define-key clojure-ts-mode-map (kbd "C-c C-f") 'zprint))
#+end_src

* Svelte
** svelte-mode
#+begin_src emacs-lisp
  (straight-use-package 'svelte-mode)
#+end_src

* Typescript

** typescript-mode
#+begin_src emacs-lisp
  (setq typescript-indent-level 2
        typescript-ts-mode-indent-offset 2)

  (add-to-list 'auto-mode-alist (cons "\\.ts\\'" 'typescript-ts-mode))
  (add-to-list 'auto-mode-alist (cons "\\.tsx\\'" 'tsx-ts-mode))

  (setq lsp-typescript-preferences-quote-style "single"
        lsp-typescript-surveys-enabled nil
        lsp-typescript-format-enable nil)

  (make-variable-buffer-local 'lsp-enable-indentation)
  (setq-default lsp-enable-indentation t)

  (add-hook 'tsx-ts-mode-hook
            (lambda ()
              (setq-local lsp-enable-indentation nil)))
#+end_src

** Deno support

#+begin_src emacs-lisp
  (straight-use-package 'deno-ts-mode)
#+end_src

** prisma
#+begin_src emacs-lisp
  (straight-use-package '(prisma-mode :host github
                                      :repo "davidarenas/prisma-mode"))

  (autoload 'prisma-mode "prisma-mode" nil t)
  (add-to-list 'auto-mode-alist '("\\.prisma\\'" . prisma-mode))

  (with-eval-after-load "prisma-mode"
    (define-key prisma-mode-map (kbd "C-c C-f") 'prisma-fmt-buffer))
#+end_src

* Lua
#+begin_src emacs-lisp
  (straight-use-package 'lua-mode)
#+end_src

* Rust
** cargo.el
#+begin_src emacs-lisp
  (straight-use-package '(cargo :host github
                                :repo "DogLooksGood/cargo.el"))

  (autoload 'cargo-minor-mode "cargo" nil t)
  (add-hook 'rust-ts-mode-hook 'cargo-minor-mode)

  (setq cargo-process--custom-path-to-bin nil
        cargo-process--rustc-cmd nil)

  (with-eval-after-load "cargo"
    (define-key cargo-process-mode-map (kbd "/") 'scroll-down)
    (define-key cargo-process-mode-map (kbd "@") 'scroll-up)
    (define-key cargo-process-mode-map (kbd "\\") 'toggle-truncate-lines))
#+end_src

** rust-ts-mode
#+begin_src emacs-lisp
  (straight-use-package 'rust-mode)
  (straight-use-package 'rust-ts-mode)

  (add-hook 'rust-ts-mode-hook
            (lambda ()
              (require 'rust-mode)
              (require 'rust-compile)))

  (add-to-list 'auto-mode-alist (cons "\\.rs\\'" 'rust-ts-mode))

  (setq lsp-rust-analyzer-completion-add-call-parenthesis nil
        lsp-rust-analyzer-proc-macro-enable t
        lsp-rust-analyzer-server-format-inlay-hints nil)
#+end_src

Write a command to switch between wasm32 and native target triple.

#+begin_src emacs-lisp
  (defun rust-toggle-lsp-target ()
    (interactive)
    (require 'lsp-rust)
    (when
        (y-or-n-p (format "Current target is [%s], switch?"
                             (or lsp-rust-analyzer-cargo-target "default")))
      (if lsp-rust-analyzer-cargo-target
          (setq lsp-rust-analyzer-cargo-target nil
                cargo-process--command-check "check")
        (setq lsp-rust-analyzer-cargo-target "wasm32-unknown-unknown"
              cargo-process--command-check "check --target wasm32-unknown-unknown"))))
#+end_src

* Nix

#+begin_src emacs-lisp
  (straight-use-package 'nix-mode)
  (add-to-list 'auto-mode-alist '("\\.nix\\'" . nix-mode))
#+end_src

** nixpkgs-fmt
#+begin_src emacs-lisp
  (straight-use-package 'nixpkgs-fmt)

  (with-eval-after-load "nixpkgs-fmt"
    (define-key nix-mode-map (kbd "C-c C-f") 'nixpkgs-fmt)
    (add-hook 'nix-mode-hook 'nixpkgs-fmt-on-save-mode))
#+end_src

* Solidity
#+begin_src emacs-lisp
  (straight-use-package 'solidity-mode)

  (straight-use-package 'company-solidity)
  (straight-use-package 'solidity-flycheck)

  (with-eval-after-load "solidity-mode"
    (require 'company-solidity)
    (require 'solidity-flycheck))
#+end_src

* Restclient
#+begin_src emacs-lisp
  (straight-use-package 'restclient)
  (add-to-list 'auto-mode-alist '("\\.restclient" . restclient-mode))
#+end_src

* HTML
#+begin_src emacs-lisp
  (straight-use-package 'web-mode)
  (setq web-mode-markup-indent-offset 2
        web-mode-css-indent-offset 2)

  (add-to-list 'auto-mode-alist
               '("\\.html\\'" . web-mode))
#+end_src

#+begin_src emacs-lisp
  (setq-default css-indent-offset 2
                js-indent-level 2)
#+end_src

** Emmet
#+begin_src emacs-lisp
  (straight-use-package 'emmet-mode)

  (autoload 'emmet-expand-line "emmet-mode" nil t)

  (with-eval-after-load "mhtml-mode"
    (define-key mhtml-mode-map (kbd "M-RET") 'emmet-expand-line))

  (with-eval-after-load "svelte-mode"
    (define-key svelte-mode-map (kbd "M-RET") 'emmet-expand-line))
#+end_src

* Move
#+begin_src emacs-lisp
  (straight-use-package 'move-mode)
#+end_src

* KDL
** kdl-mode
#+begin_src emacs-lisp
  (straight-use-package '(kdl-mode :host github
                                   :repo "bobuk/kdl-mode"))

  (add-to-list 'auto-mode-alist '("\\.kdl\\'" . kdl-mode))
  (add-hook 'kdl-mode-hook (lambda () (setq-local tab-width 2)))
  (autoload 'kdl-mode "kdl-mode")
#+end_src

* Just

** Just-mode
#+begin_src emacs-lisp
  (straight-use-package 'just-mode)

  (defun +just-mode-hook ()
    (modify-syntax-entry ?- "_"))

  (add-hook 'just-mode-hook '+just-mode-hook)
#+end_src

** Justl

Execute recipes in Justfile.

#+begin_src emacs-lisp
  (straight-use-package 'justl)

  (autoload 'justl-exec-recipe-in-dir "justl" t t)

  (keymap-set global-map "C-c j" 'justl-exec-recipe-in-dir)
#+end_src

** Rerun

Execute the last recipe by finding the =*just*= buffer and call ~justl-recompile~.

#+begin_src emacs-lisp
  (defun justl-execute-last-recipe ()
    (interactive)
    (when-let* ((curr-win (selected-window))
                (just-buf (get-buffer "*just*")))
      (with-current-buffer just-buf
        (direnv-update-directory-environment)
        (call-interactively 'justl-recompile))
      (select-window curr-win)))

  (keymap-set global-map "C-c J" 'justl-execute-last-recipe)
#+end_src

* Treesit-auto

Install tree-sitter modules automatically.

#+begin_src emacs-lisp
  (straight-use-package 'treesit-auto)
  (require 'treesit-auto)
  (setq treesit-auto-install nil
        treesit-auto-langs '(html clojure typescript tsx))
  (global-treesit-auto-mode)
#+end_src

* YAML
#+begin_src emacs-lisp
  (straight-use-package 'yaml-mode)
#+end_src

* Docker
#+begin_src emacs-lisp
  (straight-use-package 'docker)
  (straight-use-package 'dockerfile-mode)

  (autoload 'docker "docker" nil t)
#+end_src
